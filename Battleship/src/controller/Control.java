package controller;

import java.awt.Color;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.awt.event.WindowEvent;
import java.awt.event.WindowListener;

import javax.swing.JList;
import javax.swing.JOptionPane;

import controller.MatchState.Match_State;
import model.Manage;
import model.Ship;
import server_client.Client;
import server_client.Message;
import server_client.Message.Msg_type;
import view.Alert;
import view.Frame;
import view.Chat.Chat_message_type;

/**
 * It manages JButton events with ActionListener, Right click event with MouseListener and keyboards event with KeyListener.
 */
public class Control implements ActionListener, MouseListener, KeyListener, WindowListener
{
	/**
	 * Frame reference
	 */
	private Frame f;
	/*
	 * Manage reference
	 */
	private Manage g;
	/*
	 * User's nickname, chosen when he connects to serer
	 */
	private String nickname = "";
	/**
	 * Ship used for managing reposition of another ship
	 */
	private Ship toMove = null;
	/**
	 * Backup of last cell I was on. For viewing the possible position of the ship when it is turned, without moving to another cell.
	 */
	private int lastCell[] = new int[2];
	/**
	 * User's state
	 */
	public MatchState state;
	/**
	 * Client created when user connects to server.
	 */
	private Client c;
	/**
	 * Message object for sending messages to other clients
	 */
	private Message m;
	
	/**
	 * Constructor; It sets starting ships position
	 * 
	 * @param f Frame reference of the GUI.
	 * @param g Manage reference, for managing ships movement
	 */
	public Control(Frame f, Manage g)
	{
		this.f = f;
		this.g = g;
		state = new MatchState();
		
		setShips();
		
		listeners();
	}
	
	/**
	 * It sets randomly starting ships position and checks if they are correctly positioned
	 */
	public void setShips()
	{
		g.setRandomShipsPosition();
		
		// validate position
		while(!validateShips())
		{
			g.setRandomShipsPosition();
		}
		f.getDashboard().setShips();
	}
	
	/**
	 * It checks if ships position is valid for the grid provided by the frame.
	 * 
	 * @return true if all the ships are inside the grid
	 */
	public boolean validateShips()
	{
		for(int i=0;i<g.getplayer_ships().length;i++)
		{
			if(!f.getDashboard().validateShip(g.getplayer_ships()[i]))
				return false;
		}
		return true;
	}
	
	/**
	 * It records listeners for managing events generated by JButtons objects, keyboard and mouse click.
	 */
	public void listeners()
	{
		// start menu buttons
		f.getMenu().getPlay().addActionListener(this);
		f.getMenu().getHowPlay().addActionListener(this);
		f.getMenu().getQuit().addActionListener(this);
		// login
		f.getLoginPanel().getBtn_login().addActionListener(this);
		f.getLoginPanel().getBtn_reg().addActionListener(this);
		f.getLoginPanel().getBtn_exit().addActionListener(this);
		// player grid / opponent grid - click and mouse management
		for(int i = 0; i < 10; i++)
		{
			for(int j = 0; j < 10; j++)
			{
				f.getDashboard().getPlayerCoor()[i][j].addActionListener(this);
				f.getDashboard().getOpponentCoor()[i][j].addActionListener(this);
				
				f.getDashboard().getPlayerCoor()[i][j].addMouseListener(this);
				f.getDashboard().getOpponentCoor()[i][j].addMouseListener(this);
			}
		}
		// dashboard buttons
		f.getDashboard().getBtn_random_positioning().addActionListener(this);
		f.getDashboard().getBtn_quit().addActionListener(this);
		f.getDashboard().getBtn_start().addActionListener(this);
		f.getDashboard().getChat().getBtnSendMsg().addActionListener(this);
		// keyboard listener
		f.addKeyListener(this);
		// UsersOnline btn_play
		f.getUsersOnline().getBtnPlay().addActionListener(this);
		// window listener
		f.addWindowListener(this);
	}

	/**
	 * It manages events generated by JButton objects
	 */
	@Override
	public void actionPerformed(ActionEvent e)
	{
		//menu
		
		// PLAY
		if(e.getSource() == f.getMenu().getPlay())
		{
			f.changePanel(f.getLoginPanel(),f.getMenu());
		}
		// HOW PLAY
		if(e.getSource()==f.getMenu().getHowPlay())
		{
			f.changePanel(f.getHowPlay(),f.getMenu());
		}
		// ESC
		if(e.getSource()==f.getDashboard().getBtn_quit() || e.getSource()==f.getMenu().getQuit())
		{
			quitGame();
		}
	
		// Connect to server - Login - Register
		if(e.getSource() == f.getLoginPanel().getBtn_login() || e.getSource() == f.getLoginPanel().getBtn_reg()) 
		{
			nickname = f.getLoginPanel().getT_nickname().getText();
			String password = f.getLoginPanel().getT_password().getText();
			String host = f.getLoginPanel().getT_ip().getText();

			// checks if nickname or passowrd are empty
			if(nickname.isBlank() || password.isBlank() || host.isBlank())
				new Alert(f, "Compile the form","error.png").showAlert();
			//TODO check if ip form
			else
			{
				// create client
				if(e.getSource() == f.getLoginPanel().getBtn_login())
					c = new Client(nickname, password, Msg_type.LOGIN, f, g, state, host);
				else
					c = new Client(nickname, password, Msg_type.SIGN_UP, f, g, state, host);
			}
				
		}
		
		// return to menu
		if(e.getSource() == f.getLoginPanel().getBtn_exit())
		{
			f.changePanel(f.getMenu(), f.getLoginPanel());
		}
		
		// Sending a request to another client for starting a match
		if(e.getSource() == f.getUsersOnline().getBtnPlay())
		{
			JList<String> list_users = f.getUsersOnline().getList_users();

			// if I haven't selected any user --> error
			if(list_users.getSelectedValue() == null)
				new Alert(f, "Select a user to play with","error.png").showAlert();
			else
			{
				// send request 
				m = new Message(nickname,list_users.getSelectedValue(),"",Msg_type.ASKING_FOR_PLAYING);
				c.sendMessage(m);
				state.state = Match_State.WAITING_FOR_START;
				f.getUsersOnline().getBtnPlay().setEnabled(false);
			}
		}
		
		//Dashboard
		
		// When the game has to start, both users state is TO_START or OPPONENT_TO_START 
		if(state.state == Match_State.TO_START || state.state == Match_State.OPPONENT_TO_START)
		{
			// Start game
			if(e.getSource()==f.getDashboard().getBtn_start())
			{
				// update dashboard
				f.getDashboard().readyToStart();
				String msg = nickname + " is ready to play";
				f.getDashboard().getChat().addMsg(msg,Chat_message_type.EVENT);
				
				// send CHAT_EVENT Message for communicate to the opponent that I'm ready to play
				m = new Message(nickname, c.getOpponent(), msg, Msg_type.CHAT_EVENT);
				c.sendMessage(m);
				
				// first client that is ready to play achieve the state MY_TURN
				if(state.state == Match_State.TO_START)
					state.state = Match_State.MY_TURN;
				// second client ready to play changes his state from OPPONENT_TO_START to OPPONENT_TURN
				if(state.state == Match_State.OPPONENT_TO_START)
					state.state = Match_State.OPPONENT_TURN;
			}

			// random position
			if(e.getSource()==f.getDashboard().getBtn_random_positioning()) 
			{
				setShips();
			}
			
			// ship movement management
			
			// First step: select the ship to move
			if(toMove == null)
			{
				// find the ship to move
				for(int i = 0; i < 10; i++)
				{
					for(int j = 0; j < 10; j++)
					{
						if(e.getSource()==f.getDashboard().getPlayerCoor()[i][j])
						{
							String coordinata = f.getDashboard().getPlayerCoor()[i][j].getActionCommand();
							// check if the clicked cell is associated to a ship
							if(g.isShip(coordinata))
							{
								// ToMove becomes the found ship, and it remains selected with a green border
								toMove = g.getShip(coordinata);
								f.getDashboard().selectShip(toMove,Color.green);
							}
							
						}
							
					}
				}
			}
			// Second step: determine the new ship position
			else
			{
				// find clicked cell
				for(int i = 0; i < 10; i++)
				{
					for(int j = 0; j < 10; j++)
					{
						if(e.getSource()==f.getDashboard().getPlayerCoor()[i][j])
						{
							String coordinata = f.getDashboard().getPlayerCoor()[i][j].getActionCommand();
							// check that I haven't clicked above another ship. BTW, I can still click on the same ship that I want to move
							if(toMove.isShip(coordinata) || !g.isShip(coordinata))
							{
								// create new ship
								Ship newShip = new Ship(coordinata, toMove.getSize(), toMove.getDirection());
								// checking that there are no ships nearby
								if(g.isShipNear(toMove,newShip))
								{
									// error
									new Alert(f,"Not valid position","error.png").showAlert();
								}
								else
								{
									// validate new coordinates for the grid
									if(f.getDashboard().validateShip(newShip))
									{
										// Change the old ship with the new one
										g.changeShip(toMove,newShip);
										// update GUI
										f.getDashboard().setShips();
									}
									else
									{
										// error
										new Alert(f,"Unavailable space","error.png").showAlert();
									}
								}	
							}
							else
								// error
								new Alert(f,"Not valid location","error.png");
						}
							
					}
				}
				
				// If the ship has been turned, but an error occurred, turn again the ship
				if(toMove.isTurned())
				{
					toMove.turn();
					toMove.changeDirection();
				}
				
				toMove = null;
				// update dashboard
				f.getDashboard().setShips();
			}
		}
		else
		{
			// send MSG in chat
			if(e.getSource()==f.getDashboard().getChat().getBtnSendMsg())
			{
				String msg = f.getDashboard().getChat().getTextField().getText();
				
				// check if msg is empty
				if(msg.isBlank())
					new Alert(f,"Not valid message","error.png");
				else
				{
					// update dashboard
					f.getDashboard().getChat().addMsg(msg,Chat_message_type.PLAYER);
					// send it to the opponent
					m = new Message(nickname, c.getOpponent(), msg, Msg_type.CHAT_MSG);
					c.sendMessage(m);
				}
			}
		}
		
		// When it's MY_TURN, I can attack the opponent
		if(state.state == Match_State.MY_TURN)
		{
			// find clicked cell
			for(int i = 0; i < 10; i++)
			{
				for(int j = 0; j < 10; j++)
				{
					if(e.getSource()==f.getDashboard().getOpponentCoor()[i][j])
					{
						Object coordinate = f.getDashboard().getOpponentCoor()[i][j].getActionCommand();
						m = new Message(nickname, c.getOpponent(), coordinate, Msg_type.HIT_CELL);
						// send the coordinate (associated to the clicked cell) to the opponent
						c.sendMessage((Object)m);
						
						// deselect clicked cell
						f.getDashboard().not_Hover_cell(f.getDashboard().getOpponentCoor(), i, j, toMove);
					}
				
				}
			}
				
		}

	}

	
	// mouse
	
	/**
	 * It highlights the grid cell I am on. 
	 */
	// mouse hover
	@Override
	public void mouseEntered(MouseEvent e) 
	{
		// find the cell on which the mouse is located (mouse location on Player grid only shown before the start of the match)
		if(state.state == Match_State.TO_START || state.state == Match_State.OPPONENT_TO_START)
		{
			for(int i = 0; i < 10; i++)
			{
				for(int j = 0; j < 10; j++)
				{
					if(e.getSource()==f.getDashboard().getPlayerCoor()[i][j])
					{
						f.getDashboard().hover_cell(f.getDashboard().getPlayerCoor(),i,j,toMove);	
						// save last cell position
						lastCell[0] = i;
						lastCell[1] = j;
					}
						
				}
			}
		}
		
		// if MY_TURN show where mouse is hover the opponent grid
		if(state.state == Match_State.MY_TURN)
		{
			for(int i = 0; i < 10; i++)
			{
				for(int j = 0; j < 10; j++)
				{
					if(e.getSource()==f.getDashboard().getOpponentCoor()[i][j])
					{
						f.getDashboard().hover_cell(f.getDashboard().getOpponentCoor(),i,j,toMove);	
					}
						
				}
			}
		}
	}
	
	/**
	 * It stops highlighting a grid cell, when I am no longer above it
	 */
	// mouse not hover
	@Override
	public void mouseExited(MouseEvent e) 
	{
		// Before the start of a match, if I'm no longer above a Player grid cell, deselect it or the entire ship.
		if(state.state == Match_State.TO_START || state.state == Match_State.OPPONENT_TO_START)
		{
			for(int i = 0; i < 10; i++)
			{
				for(int j = 0; j < 10; j++)
				{
					
					if(e.getSource() == f.getDashboard().getPlayerCoor()[i][j])
					{
						deselect(i,j);
					}
				}
			}
		}
		
		// When it's my turn to attack, deselect Opponent grid cells, when I'm no longer above one of them.
		if(state.state == Match_State.MY_TURN)
		{
			for(int i = 0; i < 10; i++)
			{
				for(int j = 0; j < 10; j++)
				{
					if(e.getSource() == f.getDashboard().getOpponentCoor()[i][j])
					{
						f.getDashboard().not_Hover_cell(f.getDashboard().getOpponentCoor(), i, j, toMove);
					}
						
				}
			}
		}
		
	}
	
	/**
	 * It manages the deselection of a cell, when I'm no longer above it. 
	 * 
	 * If I was above a ship, this method deselects it all. 
	 * 
	 * If I'm moving a ship to another position, that ship remains highlighted.
	 * 
	 * 
	 * Grid cells are managed in a JButton matrix, so I need two indices to find a cell.
	 * 
	 * @param i first index of the JButton matrix
	 * @param j second index of the JButton matrix
	 * 
	 */
	public void deselect(int i, int j)
	{
		// If I'm on a ship, deselect it all
		if(g.isShip(f.getDashboard().getPlayerCoor()[i][j].getActionCommand()))
		{
			Ship to_deselect = g.getShip(f.getDashboard().getPlayerCoor()[i][j].getActionCommand());
			
			if(toMove != to_deselect)
				f.getDashboard().deselectShip(to_deselect,Color.decode("#5D8FC2"),toMove);
		}
		// otherwise, deselect just a cell
		else
			f.getDashboard().not_Hover_cell(f.getDashboard().getPlayerCoor(), i, j, toMove);
	}
	
	/**
	 * It manages the event generated by clicking esc on a keyboard when I'm on the HowPlay JPanel or login_panel
	 */
	@Override
	public void keyPressed(KeyEvent e) 
	{
		// When I'm viewing the rules and I click esc on keyboard, return to the menu
		if(f.isAncestorOf(f.getHowPlay()) && e.getKeyCode() == 27)
		{
			f.changePanel(f.getMenu(),f.getHowPlay());
		}
	}
	
	/**
	 * It manages events generated by right mouse click for turning ships.
	 */
	@Override
	public void mousePressed(MouseEvent e) 
	{
		// if I'm on dashboard
		if(f.isAncestorOf(f.getDashboard()))
		{
			// if I'm moving a ship
			if(toMove != null)
			{
				// right click --> turn the ship
				if(e.getButton()==MouseEvent.BUTTON3)
				{
					toMove.changeDirection();
					toMove.turn();
					// deselect everything except the ship to move
					for(int i = 0; i < 10; i++)
					{
						for(int j = 0; j < 10; j++)
						{
							// mantiene selezionata la posizione che potrebbe assumere la nave
							f.getDashboard().hover_cell(f.getDashboard().getPlayerCoor(), lastCell[0], lastCell[1], toMove);
							deselect(i,j);
						}
					}
					
				}
			}
		}

	
	}
	/**
	 * Quit the game
	 */
	public void quitGame()
	{
		// controlled exit
		int check = JOptionPane.showConfirmDialog(f, "Are you sure you want to quit?", "Exit", JOptionPane.YES_NO_OPTION, JOptionPane.DEFAULT_OPTION);
		
		switch(check)
		{
			case JOptionPane.YES_OPTION:
			{
				// if I was connected
				if(c != null)
				{
					// disconnect
					Message m = new Message(nickname,"","",Msg_type.CLOSE);
					c.sendMessage(m);
				}
				System.exit(1);
			}
				
		}
	}
	
	@Override
	public void windowClosing(WindowEvent e) {
		quitGame();
	}

//----------------------------------------------
	/**
	 * MouseListener method, not used
	 */
	@Override
	public void mouseReleased(MouseEvent e) {}
	/**
	 * MouseListener method, not used
	 */
	@Override
	public void mouseClicked(MouseEvent e) {}
	/**
	 * KeyListener method, not used
	 */
	@Override
	public void keyTyped(KeyEvent e) {}
	/**
	 * KeyListener method, not used
	 */
	@Override
	public void keyReleased(KeyEvent e) {}
//----------------------------------------------	

	@Override
	public void windowOpened(WindowEvent e) {}

	@Override
	public void windowClosed(WindowEvent e) {}

	@Override
	public void windowIconified(WindowEvent e) {}

	@Override
	public void windowDeiconified(WindowEvent e) {}

	@Override
	public void windowActivated(WindowEvent e) {}

	@Override
	public void windowDeactivated(WindowEvent e) {}


}
